# Веб сервер

**Веб сервер** предназначен для хранения файлов на удаленном компьютере, получение и отправка запросов, запуск программ, составление веб-страниц, защита информации, идентификация клиентов, учет активности пользователей и т.д.

По сути веб-сервер ждем когда в него поступит запрос от пользователя по определенному URL, веб-сервер обработает его по указанным ему инструкциям ( запишет в бд, отдаст файл, развернет какуйю-то технологию и т.д. ) и выдаст пользователю ответ. Ответ так же зависит от настроек, но в самом простом примере по запросу какой либо странице, сервер находит нужный html файл и отправит обратно в браузер, от куда пользователь делал запрос и браузер отобразит этот файл. Если никакого файла нет, по запросу от пользователя, сервер отдать html файл с 404 ошибкой и дальше пройдет по аналогичной схеме что и с отработанным правильным запросом.


Веб сервер всегда дает пониманиме принципов обмена информацией. Для этого используются алгоритмы, которые называются протоколами. Каждый URL-запрос, начинается с названия протокола ( *ftp, http, https* и т.д. )

HTTP - протокол передачи гипертекста. Страницы сайта в браузере всегда имеют вид гипертекстового документа. Веб-сервер отдает файлы в таком виде и браузер отображает их.

**DNS** - это не то же самое что и домен.
Домен это просто удобочитаемые для пользователя слова которые он вбивает в строке поиска браузера. А вот **DNS** сервер уже настраивает перенаправление этих доменов на IP адресс сервера на котором вы работаете.
На сколько я понял, прям очень грубо говоря, я покупаю домен - my-domain.ru ( *где my-domain это домен второго уровня, а ru это домен первого уровня.* ) и в dns сервисе настраиваю поддомен **mail.my-domain.ru**. По мимо этого у меня есть сервер с ip **123.123.123.123**. В **dns** сервисе я настраиваю перенаправление с **my-domain.ru** на **123.123.123.123**, dns это запоминает и в последующем когда пользователь будет в адресной строке вбивать **my-domain.ru** его будет перенаправлять на **123.123.123.123**.

> так же я думаю что поддомены можно настроить на порты сервера. Но пока что я не знаю. Это значит что можно сделать так **mail.my-domain.ru** и перенаправить на **123.123.123.123:4320**

[Домашний веб-сервер для чайников](https://habr.com/ru/articles/650117/)
[Домащний файловый сервер]()


# Настройка входа на сервер

## Зайти на сервер

Команда:

`ssh server_username@server_ip`

Пример:

`ssh root@123.123.123.123`

## Обновление пакетов и программ

* Очистить кэш - `sudo apt clean all`
* Обоновить версии пакетов всех программ - `sudo apt update`
* Установка всех программ по обновленным версиям пакетов - `sudo apt dist-upgrade`

Команда:

`sudo apt clean all && sudo apt update && sudo apt dist-upgrade`

> если спросят обновить ли конфиг ssh, нужно выбрать пункт оставить локальную весрию *"keep local version"*

## Создать пользователя системы

Создаем нового пользователя системы, что не работать с пользователем root. Плохая практика работать под пользователем root

#### **Создать пользователя**

Команда:

`adduser username`

Пример:

`adduser ltwixy`

Придумываем пароль, который будет использоваться для будущего логина через [ssh](#зайти-на-сервер)

#### **Даем права админа новому пользователю**

Команда:

`gpasswd -a username sudo`

Пример:

`gpasswd -a ltwixy sudo`

#### **Переклються на нового пользователя**

Команда:

`su - username`

Пример:

`su - ltwixy`

> Хорошая практика подключаться к серверу через ssh

#### **Перейти в папку *.ssh***

Команда:

`cd .ssh`

#### **Если папки нет, то создать ее:**

Команда:

`mkdir .ssh`


#### **Ограничить права доступа к этой папке**

Команда:

`chmod 700 .ssh`

> Для входа на сервер, по стандарту используется *22 порт*. Желательно его заменить на какой нибудь другой.

#### **Посмотреть используется ли нужный нам порт в системе**

Команда:

`grep -w needed_port /etc/services`

ИЛИ для macos

`sudo lsof -iTCP:needed_port -iUDP:needed_port -n -P`

Пример:

`grep -w 5050 /etc/services`

ИЛИ для macos

`sudo lsof -iTCP:5050 -iUDP:5050 -n -P`

Если ничего не вышло, значит порт свободен.

#### **создать файл для авторизаций через ssh**

*В системе должен быть файл с информацией какие ключи могут авторизовываться в нашу машину/нащ сервер.*

Команда:

`nano .ssh/authorized_keys`

И нужно вставить туда публичный ключ, который будет использоваться для авторизации.

#### [**Создать ключ на локальной машине**](https://learn.microsoft.com/ru-ru/azure/virtual-machines/linux/create-ssh-keys-detailed#generate-keys-with-ssh-keygen)

Команда:

`ssh-keygen -t rsa -m PEM -b 4096 ["identification_phrase"] [-f "path_to_file]"`

Пример:

`ssh-keygen -t rsa -m PEM -b 4096 "ltwixy@mail.ru" -f ~/.ssh/vultr_keys/auth_vultr_key`

Если не указать путь к определнному файлу, то по умолчанию эта команда перезапишет имеющиеся ключи в папке *.ssh*

> Убедитесь что в конце нового файла с непубличным ключом есть пустая строка, иначе ключ не сработает для авторизации.

#### **Скопировать публичный ключ**

Команда:

`cat path_to_file`

Пример:

`cat ~/.ssh/vultr/auth_vultr_key`

Данные которые отобразились в консоле, нужно скопировать и поместить в файл *authorized_keys* на сервере.

#### **Задать новые права на этот файл**

Команда:

`chmod 600 ~/.ssh/authorized_keys`

#### **Нужно перезагрузить ssh сервис**

Команда:

`sudo service ssh restart`

Далее меняем конфигурационные файлы для авторизации на сервере.

Заходим под пользователем root, все еще.

Так как мы сейчас под новым пользователем, нам нужно перейти обратно в root.

#### **Разлогиниться новым пользователем**

Команда:

`exit`

Если бы мы сидели под *root* пользователм, нас бы выкинул из сервера, но так как мы изначально заходили под пользователем *root* и после переходили на другого, команда *exit* нас выкинула на root пользователя.

#### **Перписать конфиг службы ssh**

Команда:

`nano /etc/ssh/sshd_config`

* В открытом файле перейти до строки *Port*, по дефолту, как я писал раньше, ssh работает на 22 порту, нам его нужно заменить на новый [который мы проверяли](#посмотреть-используется-ли-нужный-нам-порт-в-системе) и убрать "#" решетку в начале строки ( # - означает что эта строка коментарий )
* Перейти до строки *PermitRootLogin* перевести в значение *no*, тем самым мы запрещаем заходим на сервер под пользователем **root**
* Перейти до строки *PasswordAuthentication* так же перевохим в значение *no*, что бы нельзя было зайти используя пароль

> В этом файле хранится строка *AuthorizedKeysFile* значения которой - это файлы в которые можно записать публичные ssh ключи что бы в итоге можно было авторизовываться

Сохраняем.

**Даем права на выполнение всех операций новому пользователю**

Нужно обновить файл /etc/sudoers

Командв

`nano /etc/sudoers`

и в конце файла добавить следующую строку

`username ALL=(ALL) NOPASSWD: ALL`

Пример:

`ltwixy ALL=(ALL) NOPASSWD: ALL`

После всего, что бы зайти на сервер нужно прописать команду

`ssh -i path-to-ssh-key -p 5050 usernmae@server_ip`


## Установка web-сервера NGINX

#### **Установить web-сервер на машину**

Команда:

`sudo apt install nginx`

#### **Посмотреть статус NGINX**

Команда:

`sudo systemctl status nginx`

Терминал выведет полный статус и в строке *Active* должно быть значение *active (running)*

#### **Настроить запуск NGINX при запуске системы**

Команда:

`sudo systemctl enable nginx`

#### **Перейти в домащнюю директорию пользователя**

Команда:

`cd /home/username`

Пример:

`cd /home/ltwixy`

#### **Создать папку где будет лежать приложение/приложения**

Команда:

`mkdir folder_name`

Пример:

`mkdir webapps`

#### **Задем права этой папке на чтение и запись**

Команда:

`sudo chmod 777 /home/username/folder_name`

Пример:

`sudo chmod 777 /home/ltwixy/webapps`

Таким образом можно будет вставлять туда файлы и папки извне.



<!-- TODO -->
Дальше нужно описать как перенести туда наши проекты


#### **Добавить в файл конфига NGINX перенесенную папку в webapps.**

( Представим что мы в папку webapps добавили папку mysite.com и внутри mysite.com папки есть исполняемый index.html файл )

Команда:

`sudo nano /etc/nginx/sites-available/mysite.com`

И прописываем конфиг в этом файле

Конфиг:

```
server {
  listen server_ip:wanted_port;
  root /home/username/path_to_site_folder;
  index index.html
  location / {
    try_files $uri.html $uri $uri/ =404
  }
}
```
Пример:

```
server {
  listen 95.179.239.164:80;
  root /home/ltwixy/webapps/mysite.com;
  index index.html
  location / {
    try_files $uri.html $uri $uri/ =404
  }
}
```
#### **Активировать файл конфига в NGINX**

Команда:

`sudo ln -s /etc/nginx/sites-available/mysite.com /etc/nginx/sites-enabled/mysite.com`

Эта команда создаст файл ссылку, которая будет ссылаться на наш фалй, таким образом создав один раз конфигурационный фалй в папке sites-available, нам не нужно дублировать этот же файл, а можно создать файл-ссылку ( возможности ubuntu, а может и всего linux, точно не знаю )


#### **Проверяем активировался ли наш конфиг в NGINX**

Команда:

`sudo nginx -t`

Должна быть строка что-то вроде

`configuration file /etc/nginx/nginx.conf test is successfull`


### Создать ssl сертификат

> Для создания ssl сертификата нужно обязательно освободить 80 порт и подвзять домен к ip сервера.

1. Приоьрести домен
2. Привязать ip сервер через "A-record" в сервисе где купили домен. Создать 2 записи:
   1. Запись привязки ip сервера к названию домена
   2. Запись привзяки ip сервера к www
3. Дождаться когда настройки на домене войдут в силу

##### Для проверки подвязался ли wps сервер к домену нужно пингануть сервер

```shell
nslookup {название вашего домена}.{выбранный домен (.com|.org)}
```

Ответ должен быть примерно таким:

```shell
Server:		192.168.0.1
Address:	192.168.0.1#53

Non-authoritative answer:
Name:	{название вашего домена}.{выбранный домен (.com, .org)}
Address: {ip сервера}
```

ИЛИ

```shell
ping {название вашего домена}.{выбранный домен (.com|.org)}
```

Ответ должен быть примерно таким:

```shell
PING {название вашего домена}.{выбранный домен (.com|.org)} ({ip сервера}): 56 data bytes
64 bytes from {ip сервера}: icmp_seq=0 ttl=53 time=97.604 ms
64 bytes from {ip сервера}: icmp_seq=1 ttl=53 time=97.551 ms
```

##### Создать сертификат на сервере

- Зайти на сервер

```shell
ssh root@{ip сервера}
```

- Посмотреть открыт ли 80 порт

```shell
ss -tulnp | grep :80
```

ИЛИ

```shell
netstat -tulnp | grep :80
```

  - Остановить все что находится на 80 порту. Если ничего нет, но certbot может ругаться то значит порт возможно заблокирован
  - Проверить брандмауэр (firewall), не заблокирован ли порт
    
    ```shell
    ufw status
    ```

  - Если видишь 80/tcp DENY или 80/tcp CLOSED, значит, порт заблокирован.
  - Открыть порт можно так:

    ```shell
    ufw allow 80/tcp
    ufw allow 443/tcp
    ufw reload
    ```

> 80 порт должен быть открыт, потому что Let’s Encrypt при создании сертификатов пытается
> запустить тестовый сервер что бы проверить доступность сервера

- На хостовой машине установить Certbot:

```shell
apt update && apt install -y certbot
certbot certonly --standalone -d {название вашего домена}.{выбранный домен (.com|.org)} -d www.{название вашего домена}.{выбранный домен (.com|.org)}
```

*После успешной генерации сертификатов они будут лежать здесь:*

```shell
/etc/letsencrypt/live/{название вашего домена}.{выбранный домен (.com|.org)}/fullchain.pem
/etc/letsencrypt/live/{название вашего домена}.{выбранный домен (.com|.org)}/privkey.pem
```

- Прокинуть сертификаты внутрь docker контейнера.

```shell
docker run -d -p 80:80 -p 443:443 \
      --name telegram-mini-app-container \
      -v /etc/letsencrypt/live/{название вашего домена}.{выбранный домен (.com|.org)}:/etc/letsencrypt/live/{название вашего домена}.{выбранный домен (.com|.org)}:ro \
      -v /etc/letsencrypt/archive/{название вашего домена}.{выбранный домен (.com|.org)}:/etc/letsencrypt/archive/{название вашего домена}.{выбранный домен (.com|.org)}:ro \
      telegram-mini-app-image
```

***Не обязательно создавать volume, можно прокидывать любым удобным способом***

- Проверить до какого числа сертификат действует

```shell
certbot certificates
```

Ответ примерно такой:

```shell
Saving debug log to /var/log/letsencrypt/letsencrypt.log

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Found the following certs:
  Certificate Name: {название вашего домена}.{выбранный домен (.com|.org)}
    Serial Number: 470227cf639951638e1918e8e973732fad9
    Key Type: RSA
    Domains: {название вашего домена}.{выбранный домен (.com|.org)} www.{название вашего домена}.{выбранный домен (.com|.org)}
    Expiry Date: 2025-06-01 11:33:08+00:00 (VALID: 89 days)
    Certificate Path: /etc/letsencrypt/live/{название вашего домена}.{выбранный домен (.com|.org)}/fullchain.pem
    Private Key Path: /etc/letsencrypt/live/{название вашего домена}.{выбранный домен (.com|.org)}/privkey.pem
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
```

> Сертификаты обновляются вручную

- Если сертификат не обновился автоматически. Обновить вручную

```shell
certbot renew --dry-run
```

Если тест прошел успешно, обновить реально:

```shell
certbot renew
docker restart nginx  # Если Nginx в Docker
systemctl restart nginx  # Если Nginx на хосте
```

- Если nginx запущен в docker, нужно добавить блок server в конфиг. Описано [тут](./07_nginx/index.md#настройка-для-ssl-сертификата)

