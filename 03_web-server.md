# Веб сервер

**Веб сервер** предназначен для хранения файлов на удаленном компьютере, получение и отправка запросов, запуск программ, составление веб-страниц, защита информации, идентификация клиентов, учет активности пользователей и т.д.

По сути веб-сервер ждем когда в него поступит запрос от пользователя по определенному URL, веб-сервер обработает его по указанным ему инструкциям ( запишет в бд, отдаст файл, развернет какуйю-то технологию и т.д. ) и выдаст пользователю ответ. Ответ так же зависит от настроек, но в самом простом примере по запросу какой либо странице, сервер находит нужный html файл и отправит обратно в браузер, от куда пользователь делал запрос и браузер отобразит этот файл. Если никакого файла нет, по запросу от пользователя, сервер отдать html файл с 404 ошибкой и дальше пройдет по аналогичной схеме что и с отработанным правильным запросом.


Веб сервер всегда дает пониманиме принципов обмена информацией. Для этого используются алгоритмы, которые называются протоколами. Каждый URL-запрос, начинается с названия протокола ( *ftp, http, https* и т.д. )

HTTP - протокол передачи гипертекста. Страницы сайта в браузере всегда имеют вид гипертекстового документа. Веб-сервер отдает файлы в таком виде и браузер отображает их.

**DNS** - это не то же самое что и домен.
Домен это просто удобочитаемые для пользователя слова которые он вбивает в строке поиска браузера. А вот **DNS** сервер уже настраивает перенаправление этих доменов на IP адресс сервера на котором вы работаете.
На сколько я понял, прям очень грубо говоря, я покупаю домен - my-domain.ru ( *где my-domain это домен второго уровня, а ru это домен первого уровня.* ) и в dns сервисе настраиваю поддомен **mail.my-domain.ru**. По мимо этого у меня есть сервер с ip **123.123.123.123**. В **dns** сервисе я настраиваю перенаправление с **my-domain.ru** на **123.123.123.123**, dns это запоминает и в последующем когда пользователь будет в адресной строке вбивать **my-domain.ru** его будет перенаправлять на **123.123.123.123**.

> так же я думаю что поддомены можно настроить на порты сервера. Но пока что я не знаю. Это значит что можно сделать так **mail.my-domain.ru** и перенаправить на **123.123.123.123:4320**

[Домашний веб-сервер для чайников](https://habr.com/ru/articles/650117/)
[Домащний файловый сервер]()


# Настройка входа на сервер

## Зайти на сервер

Команда:

`ssh server_username@server_ip`

Пример:

`ssh root@123.123.123.123`

## Обновление пакетов и программ

* Очистить кэш - `sudo apt clean all`
* Обоновить версии пакетов всех программ - `sudo apt update`
* Установка всех программ по обновленным версиям пакетов - `sudo apt dist-upgrade`

Команда:

`sudo apt clean all && sudo apt update && sudo apt dist-upgrade`

> если спросят обновить ли конфиг ssh, нужно выбрать пункт оставить локальную весрию *"keep local version"*

## Создать пользователя системы

Создаем нового пользователя системы, что не работать с пользователем root. Плохая практика работать под пользователем root

#### **Создать пользователя**

Команда:

`adduser username`

Пример:

`adduser ltwixy`

Придумываем пароль, который будет использоваться для будущего логина через [ssh](#зайти-на-сервер)

#### **Даем права админа новому пользователю**

Команда:

`gpasswd -a username sudo`

Пример:

`gpasswd -a ltwixy sudo`

#### **Переклються на нового пользователя**

Команда:

`su - username`

Пример:

`su - ltwixy`

> Хорошая практика подключаться к серверу через ssh

#### **Перейти в папку *.ssh***

Команда:

`cd .ssh`

#### **Если папки нет, то создать ее:**

Команда:

`mkdir .ssh`


#### **Ограничить права доступа к этой папке**

Команда:

`chmod 700 .ssh`

> Для входа на сервер, по стандарту используется *22 порт*. Желательно его заменить на какой нибудь другой.

#### **Посмотреть используется ли нужный нам порт в системе**

Команда:

`grep -w needed_port /etc/services`

Пример:

`grep -w 5050 /etc/services`

Если ничего не вышло, значит порт свободен.

#### **создать файл для авторизаций через ssh**

*В системе должен быть файл с информацией какие ключи могут авторизовываться в нашу машину/нащ сервер.*

Команда:

`nano .ssh/authorized_keys`

И нужно вставить туда публичный ключ, который будет использоваться для авторизации.

#### [**Создать ключ на локальной машине**](https://learn.microsoft.com/ru-ru/azure/virtual-machines/linux/create-ssh-keys-detailed#generate-keys-with-ssh-keygen)

Команда:

`ssh-keygen -t rsa -m PEM -b 4096 ["identification_phrase"] [-f "path_to_file]"`

Пример:

`ssh-keygen -t rsa -m PEM -b 4096 "ltwixy@mail.ru" -f ~/.ssh/vultr_keys/auth_vultr_key`

Если не указать путь к определнному файлу, то по умолчанию эта команда перезапишет имеющиеся ключи в папке *.ssh*

> Убедитесь что в конце нового файла с непубличным ключом есть пустая строка, иначе ключ не сработает для авторизации.

#### **Скопировать публичный ключ**

Команда:

`cat path_to_file`

Пример:

`cat ~/.ssh/vultr/auth_vultr_key`

Данные которые отобразились в консоле, нужно скопировать и поместить в файл *authorized_keys* на сервере.

#### **Задать новые права на этот файл**

Команда:

`chmod 600 ~/.ssh/authorized_keys`

#### **Нужно перезагрузить ssh сервис**

Команда:

`sudo service ssh restart`

Далее меняем конфигурационные файлы для авторизации на сервере.

Заходим под пользователем root, все еще.

Так как мы сейчас под новым пользователем, нам нужно перейти обратно в root.

#### **Разлогиниться новым пользователем**

Команда:

`exit`

Если бы мы сидели под *root* пользователм, нас бы выкинул из сервера, но так как мы изначально заходили под пользователем *root* и после переходили на другого, команда *exit* нас выкинула на root пользователя.

#### **Перписать конфиг службы ssh**

Команда:

`nano /etc/ssh/sshd_config`

* В открытом файле перейти до строки *Port*, по дефолту, как я писал раньше, ssh работает на 22 порту, нам его нужно заменить на новый [который мы проверяли](#посмотреть-используется-ли-нужный-нам-порт-в-системе) и убрать "#" решетку в начале строки ( # - означает что эта строка коментарий )
* Перейти до строки *PermitRootLogin* перевести в значение *no*, тем самым мы запрещаем заходим на сервер под пользователем **root**
* Перейти до строки *PasswordAuthentication* так же перевохим в значение *no*, что бы нельзя было зайти используя пароль

> В этом файле храниться строка *AuthorizedKeysFile* значения которой - это файлы в которые можно записать публичные ssh ключи что бы в итоге можно было авторизовываться

Сохраняем.

**Даем права на выполнение всех операций новому пользователю**

Нужно обновить файл /etc/sudoers

Командв

`nano /etc/sudoers`

и в конце файла добавить следующую строку

`username ALL=(ALL) NOPASSWD: ALL`

Пример:

`ltwixy ALL=(ALL) NOPASSWD: ALL`

После всего, что бы зайти на сервер нужно прописать команду

`ssh -i path-to-ssh-key -p 5050 usernmae@server_ip`


## Установка web-сервера NGINX

#### **Установить web-сервер на машину**

Команда:

`sudo apt install nginx`

#### **Посмотреть статус NGINX**

Команда:

`sudo systemctl status nginx`

Терминал выведет полный статус и в строке *Active* должно быть значение *active (running)*

#### **Настроить запуск NGINX при запуске системы**

Команда:

`sudo systemctl enable nginx`

#### **Перейти в домащнюю директорию пользователя**

Команда:

`cd /home/username`

Пример:

`cd /home/ltwixy`

#### **Создать папку где будет лежать приложение/приложения**

Команда:

`mkdir folder_name`

Пример:

`mkdir webapps`

#### **Задем права этой папке на чтение и запись**

Команда:

`sudo chmod 777 /home/username/folder_name`

Пример:

`sudo chmod 777 /home/ltwixy/webapps`

Таким образом можно будет вставлять туда файлы и папки извне.



<!-- TODO -->
Дальше нужно описать как перенести туда наши проекты


#### **Добавить в файл конфига NGINX перенесенную папку в webapps.**

( Представим что мы в папку webapps добавили папку mysite.com и внутри mysite.com папки есть исполняемый index.html файл )

Команда:

`sudo nano /etc/nginx/sites-available/mysite.com`

И прописываем конфиг в этом файле

Конфиг:

```
server {
  listen server_ip:wanted_port;
  root /home/username/path_to_site_folder;
  index index.html
  location / {
    try_files $uri.html $uri $uri/ =404
  }
}
```
Пример:

```
server {
  listen 95.179.239.164:80;
  root /home/ltwixy/webapps/mysite.com;
  index index.html
  location / {
    try_files $uri.html $uri $uri/ =404
  }
}
```
#### **Активировать файл конфига в NGINX**

Команда:

`sudo ln -s /etc/nginx/sites-available/mysite.com /etc/nginx/sites-enabled/mysite.com`

Эта команда создаст файл ссылку, которая будет ссылаться на наш фалй, таким образом создав один раз конфигурационный фалй в папке sites-available, нам не нужно дублировать этот же файл, а можно создать файл-ссылку ( возможности ubuntu, а может и всего linux, точно не знаю )


#### **Проверяем активировался ли наш конфиг в NGINX**

Команда:

`sudo nginx -t`

Должна быть строка что-то вроде

`configuration file /etc/nginx/nginx.conf test is successfull`

