> На примере vue и webpack

### Для чего нужен lazy load компонентов vue

1. Ускорение начальной загрузки приложения
   - При использовании lazyLoad компоненты подгружаются только при необходимости, то есть, когда пользователь заходит на соответствующий роут.
   - Это снижает объем данных, которые загружаются в браузер при первой загрузке приложения (уменьшается размер основного бандла JavaScript).
2. Улучшение производительности
   - Благодаря разделению кода (code splitting), приложение становится более отзывчивым. Браузеру не нужно загружать весь код сразу, что особенно важно для больших проектов с множеством страниц.
   - Это уменьшает нагрузку на память устройства пользователя.
3. Экономия трафика
   - Пользователь загружает только те части приложения, которые ему нужны. Это полезно для пользователей с медленным интернет-соединением или ограниченным трафиком.
4. Упрощение масштабируемости приложения
   - LazyLoad делает проект более масштабируемым. Вы можете добавлять новые страницы или модули без риска чрезмерного увеличения размера основного бандла.
5. Оптимизация для SEO и пользовательского опыта
   - Для SPA (Single Page Application), где используется серверный рендеринг (например, с Nuxt.js), lazyLoad позволяет быстрее отображать первую страницу, что улучшает SEO.
   - Пользователи быстрее получают доступ к основной функциональности.

> Самое главное нужно понять, что при использовании lazyLoad, все компоненты которые объявлены через lazyLoad будут иметь свой чанк файл.
> А компонент который не используется на той странице где сейчас находится пользователь, не будет подгружаться в Network.

##### Как это реализуется?

```javascript
import { createRouter, createWebHistory } from 'vue-router';

const routes = [
  {
    path: '/home',
    name: 'Home',
    component: () => import('@/views/Home.vue') // LazyLoad
  },
  {
    path: '/about',
    name: 'About',
    component: () => import('@/views/About.vue') // LazyLoad
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

export default router;
```

> Если не использовать lazyLoad, все компоненты, зарегистрированные в маршрутах, будут подгружены сразу при загрузке приложения.

**Это значит:**
- Все файлы JavaScript, включая компоненты, относящиеся к роутам, будут включены в основной бандл (main.js или app.js).
- Даже если пользователь не перейдет на определенные страницы, код всех этих компонентов будет загружен сразу при открытии приложения.

##### Без LazyLoad:

```javascript
const routes = [
  { path: '/home', component: Home },
  { path: '/about', component: About }
];
```

*Здесь и Home.vue, и About.vue загружаются сразу, даже если пользователь зашел только на /home.*

> LazyLoad перемещает компоненты в отдельные JS-файлы (chunks). Основной бандл теперь содержит только “ядро” приложения (основную логику, используемые сразу компоненты и роутер).

### Как работает lazyLoading под капотом?

Шаги работы:
1. Во время сборки:
   - Webpack или другой сборщик (например, Vite) видит динамические импорты (import()).
   - Он создает отдельные файлы (chunks) для каждого такого импорта.
   - Эти файлы хранятся отдельно от основного бандла.
2. Во время выполнения (runtime):
   - Когда пользователь заходит на страницу с lazyLoad компонентом, Vue Router вызывает соответствующий import() для этого компонента.
   - Браузер делает HTTP-запрос за нужным chunk-файлом (например, About.chunk.js).
   - После загрузки файла Vue “монтирует” компонент в приложение.

##### Как браузер понимает, когда загружать:

- Механизм основан на событии, которое происходит при переходе на роут. Vue Router видит, что для этого роута нужно загрузить компонент, и вызывает import() для этого файла.
- Если пользователь не переходит на этот роут, никакой загрузки не происходит.


### Что если мы несколько раз используем один и тот же компонент? Будет ли он дублироваться?

> Нет, в основном бандле не будет дважды один и тот же код компонента, даже если компонент используется одновременно для нескольких роутов.

1. Оптимизация повторного использования компонентов
   - При сборке Webpack или Vite не дублируют код компонентов.
   - Если ты используешь один и тот же компонент (например, заглушку <template><div></div></template>) в нескольких местах, сборщик кода объединит его в единый модуль, который будет использоваться везде, где он нужен.

```vue
<!-- Placeholder.vue -->
<template><div></div></template>
```

```javascript
// router.js
import Home from '@/views/Home.vue';
import About from '@/views/About.vue';
import Placeholder from '@/views/Placeholder.vue'; // Заглушка

const routes = [
  {
    path: '/home',
    component: () => import('@/views/Home.vue') // LazyLoad
  },
  {
    path: '/about',
    component: () => import('@/views/About.vue') // LazyLoad
  },
  {
    path: '/news',
    component: Placeholder // Без LazyLoad
  },
  {
    path: '/account',
    component: Placeholder // Без LazyLoad
  }
];

export default createRouter({
  history: createWebHistory(),
  routes
});
```

- Placeholder включается в основной бандл один раз, так как он подключен обычным способом (import Placeholder from '@/views/Placeholder.vue';).
- Home и About собираются в отдельные chunks благодаря LazyLoad (import()).

##### Почему не дублируется код?

Webpack/Vite используют граф зависимостей (dependency graph) и эффективно обрабатывают повторное использование:
- Каждый импортированный модуль или компонент компилируется в отдельный блок (module).
- Если один и тот же модуль импортируется в нескольких местах, он ссылается на одну и ту же копию в скомпилированном коде.


##### Использование analyzer для проверки

```shell
npm install --save-dev webpack-bundle-analyzer
```







