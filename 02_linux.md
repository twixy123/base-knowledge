### Дистрибутив

**Дистрибутив** - форма распространения какой-либо сущности

### Ядро

**Ядро** - основа операционной системы, которое непосредственно взаимадействует с железои, а вот уже с ядром взаимодействуют с помощью програм, например [*shell*](#gnu), а пользовательские приложение работают с [*shell*](#gnu).

### Linux

**Дистрибутив Linux** - форма распространения ядра Линукс, специально настроенных програм, диспетчера пакетов и утилит [*GNU*](#gnu)

> **Linux** - это не *Unix*.

**Linux=** - это Unix подобная система, которая использует *GNU*

**Linux** - Это ядро операционной системы. Операционные системы на базе Linux - установочный пакет ядра Linux + дополнительные пакеты с разными конфигурациями. ( *Ubuntu, Debian, Arch linux и т.д.* )

> При чем Ubuntu - построена на на самом Linux, а на  Debian

Ядро linux на 98% написано на языке C, на ассемблере написаны лишь небольшие вставки для производительности, архитектурных задач и сам загрузчик.

### GNU

**GNU** - Это и есть та самая основная штука, которая включает в себя shell/bash, cat, grep, awk.

### Процессы

В Linux есть 3 типа процессов - интерактивные, пакетные и демоны. Первые 2 могут запускаться пользователем, но интерактивные могут быть запущены через терминал, а демоны и пакетные не могут.

Что бы увидеть все выполняемые процессы в системе нужно выполнить следующую команду в терминале

`pstree`

**Пакетные процессы** - это различные скрипты резервного копирования или лругие подобные обслуживающие служебные сценарии. Как пакетные так и демоны работают в фоновом режиме.

**Демоны** отслеживают состояние той или иной сущности и гарантируют ее работоспособность ( *Типа ReplicaSet на подами в кубере* ).
Например демон принтера отслеживает состояние служб печати. Обычно названия демонов заканчиваются на "d"

Интерактивные нельзя считать демонами. Хоть их так же можно запустить в фоновом режиме, ключевое отличие в том что демонов не могут запускать пользователи.

Например, когда загрузка системы завершается, **systemd** начинает запускать демонов и интерактивные процессы. Точнее сначала программа начинает запускаться как обычный интерактивный процесс, но в какой-то момент начинает делиться на 2 идентичных потока. Это называется *forking*, разветвление. Первый поток привязан к терминалу и может продолжать работать дальше или завершиться по нужде пользователя, а вот второй уже не привязан к терминалу и в любом случае будет продолжать работать и завершить его пользователь не сможет.

#### Примеры Демонов Linux

**systemd** - следит за всеми демонами. Такой главный парень)
**udiskd** - все операции с внешними накопителями ( флешки )
**logind** - авторизация пользователя
**httpd** - демон веб-сервера, для реализации сайтов в ОС
**sshd** - поделючение к ОС удаленно, по протоколу *ssh*
**ftpd** - организовывет передачу файлов с удаленного ПК по протоколу FTP.
**crond** - планировщик задач, позволяет запускать задачи в определенное время.


### Командная оболочка

**Shell, Bash** и всякие другие программы - командная оболчка, которая позводяет запускать программы, управление дирректориеями, поиск программ в текущем каталоге и через пути PATH в конфиге тукущей оболчки. В общем по факту это надстройка над истинными командами ядра ОС. Например команда "cd", это не отдельная программа, а втроенная команда внутри оболочки. Но, например, ls - это уже внешняя программа, исполняемый файл которой лежит в файловой системе.

В системе может быть установлено несколько оболочек, но в одно время может работать только одна.

Что бы посмотреть какая оболчка у вас используется на данный момент, нужно выполнить команду:

`echo $SHELL` или `ps -p $$`

Для того что бы посмотреть все установленные оболочки:

`cat /etc/shells`

---

### **Узнать ip машины**

Команды:

- `ip r | grep default`
- `netstat -r`
- `curl ifconfig.me`
- `curl ipinfo.io/ip`

---

### **Узнать свободен ли порт**

Команды:

- `sudo lsof -i :80`
  Если порт занят, ты увидишь список процессов, использующих этот порт. Если порт не занят, команда не вернет никаких результатов.
- `netstat -an | grep LISTEN`
  Эта команда выведет список всех портов, которые находятся в состоянии прослушивания.
- `netstat -tuln | grep LISTEN`
  Эта команда выведет список всех портов, которые находятся в состоянии прослушивания.
- `netstat -an | grep 80`
  Если порт занят, ты увидишь соответствующую строку в выводе. Если порт не занят, команда не вернет никаких результатов.
- `netstat -tuln | grep :80`
  Если порт занят, ты увидишь соответствующую строку в выводе. Если порт не занят, команда не вернет никаких результатов.
- `ss -tuln | grep :80`
  Команда ss является более современной и мощной заменой для netstat.
  Если порт 80 занят, ты увидишь информацию о процессе, который использует этот порт. Если он свободен, ничего не будет отображено.

---

### Убить порт по PID

#### Проверить порт

Команда:

`lsof -i :80`

Выходные данные, если порт занят:

| COMMAND   | PID    | USER   | FD   | TYPE  | DEVICE | SIZE/OFF | NODE | NAME             |
| --------- | ------ | ------ | ---- | ----- | ------ | -------- | ---- | ---------------- |
| nginx     | 3402   | root   | 5u   | IPv4  | 34896  | 0t0      | TCP  | *:http (LISTEN)  |

#### Убить порт по PID

Команда:

`kill 3402`

**Если процесс не завершается, используй опцию -9 для принудительного завершения:**

Команда:

`kill -9 3402`

---

### Добавить alias

Вы можете создать общий файл с alias'ами и затем импортировать его как в `bashrc`, так и в `zshrc`. Вот как это можно сделать:

1. Создайте новый файл для хранения ваших общих alias'ов, например `aliases.sh`:

```bash
touch ~/aliases.sh
```

2. Откройте этот файл и добавьте в него ваши alias'ы. Например:

```bash
# aliases.sh
alias ll='ls -alF'
alias gs='git status'
# Другие ваши alias'ы
```

3. Импортируйте этот файл как в `bashrc`, так и в `zshrc`. Для этого добавьте следующую строку в конец файла `~/.bashrc` и `~/.zshrc`:

```bash
source ~/aliases.sh
```

Теперь ваши alias'ы будут доступны как в `bash`, так и в `zsh`. Если вы захотите добавить новый alias или изменить существующий, вам нужно будет сделать это только в одном месте - в файле `aliases.sh`.

---

### Команды с файлами и папками

**Скопировать файл**
```shell
cp path-folder desired-path-folder
```

---

#### Скопировать папку
```shell
cp -r path-folder desired-path-folder
```

---

#### Переименовать папку

```shell
mv старое_название_папки новое_название_папки
```

---

#### Копирование файлов из одного каталога в другой

```shell
find /path/to/source -name "*.txt" | xargs -I {} cp {} /path/to/destination
```
[как работает xargs](#xargs)

Этот пример использует find для поиска файлов с расширением .txt в исходном каталоге и передает их xargs,
который в свою очередь копирует каждый файл в указанный каталог назначения.

---

#### Использование множественных аргументов в команде

```shell
echo "file1.txt file2.txt file3.txt" | xargs cat
```
[как работает xargs](#xargs)

Здесь xargs получает список имен файлов от echo и передает их в команду cat,
чтобы объединить содержимое всех файлов в один вывод.

---

#### Выполнение команды с аргументами из файла

```shell
cat arguments.txt | xargs -I {} command {}
```
[как работает xargs](#xargs)

Этот пример передает аргументы из файла arguments.txt в команду command, которая выполняется для каждого аргумента.

---

#### Найти папку
```shell
find ./ -name 'folder-name'
```

---

#### Найти файл

```shell
find ./ -name 'file-name.js'
```

---

#### Узнать размер папок

```shell
du -sh *
```
или
```shell
ls | xargs du -sh | less
```
[как работает xargs](#xargs)

---

#### Отсортировать по подстроке из контента файлов

```shell
ls -l | grep ".txt"
```
[как работает grep](#grep)

---

#### Посмотреть права и добавить права файлу

* Посмотреть
  ```shell
  ls -l
  ```
* Добавить
  ```shell
  chmod +x tages-generate.sh
  ```
  
Права доступа к файлам:
В UNIX-подобных системах каждый файл и директория имеют атрибуты, определяющие, кто может читать, записывать и выполнять их.

**Эти атрибуты обычно представлены в виде трех групп:**

* Владелец файла (user): Пользователь, который создал файл или директорию.
* Группа (group): Группа, к которой принадлежит файл или директория.
* Остальные (others): Любые другие пользователи на системе, не являющиеся владельцем и не принадлежащие к группе.

**Для каждой из этих групп существует три основных права доступа:**

* Чтение (read): Позволяет просматривать содержимое файла или директории.
* Запись (write): Позволяет изменять содержимое файла или директории.
* Выполнение (execute): Позволяет запускать файл (для директорий - позволяет входить в них и просматривать их содержимое).

Каждое из этих прав можно установить или снять для каждой из трех групп пользователей (владельца, группы и остальных).

[Гайд по правам](https://firstvds.ru/technology/linux-permissions)

---

#### Посмотреть различия между файлами

* Просто узнать есть ли различия
  ```shell
  cmp file1.txt file2.txt
  ```
* сравнить контент двух файлов
  ```shell
  diff file1.txt file2.txt
  ```
* вывести различия в две колонки
  ```shell
  diff -y file1.txt file2.txt
  ```

Эта команда выведет различия между file1.txt и file2.txt в две колонки, построчно. В левой колонке будут строки из file1.txt, а в правой из file2.txt. Если строки идентичны, будет использован символ | между ними. Если строки отличаются, будет использован символ < для строки из первого файла и > для строки из второго файла.

---

---

### grep

Утилита grep в Unix-подобных операционных системах используется для поиска строк,
соответствующих заданному шаблону в файлах или выводе команд. Она очень мощная и гибкая,
позволяя фильтровать текст по различным критериям.

#### Поиск строки в файле

```shell
grep "шаблон" filename
```

Основные опции
- -i: Игнорировать регистр символов.
- -v: Инвертировать поиск (вывести строки, которые не соответствуют шаблону).
- -r или -R: Рекурсивный поиск по директориям.
- -n: Показать номера строк.
- -w: Искомое слово целиком.
- -o: Вывести только совпадения.
- -c: Подсчитать количество совпадений.
- -l: Вывести только имена файлов, содержащих совпадения.
- -E: Использовать расширенные регулярные выражения.

Примеры:

- ```shell
    grep -i "error" /var/log/syslog
  ```
  - Этот пример ищет слово “error” в файле /var/log/syslog.
- ```shell
    grep -r "TODO" ~/projects
  ```
  - Этот пример ищет слово “TODO” во всех файлах в директории ~/projects и всех ее поддиректориях.
- ```shell
    grep -w "error" /var/log/syslog
  ```
  - Этот пример ищет точное слово “error” в файле /var/log/syslog.
- ```shell
    grep -E "error|warning" /var/log/syslog
  ```
  - Этот пример ищет строки, содержащие “error” или “warning” в файле /var/log/syslog.
- ```shell
    grep -o "error" /var/log/syslog
  ```
  - Этот пример выведет только совпадения, без контекста строки.
- ```shell
    grep -c "error" /var/log/syslog
  ```
  - Этот пример подсчитает количество строк, содержащих “error” в файле /var/log/syslog.

---

#### grep с конвейером (pipe)

Часто grep используется в комбинации с другими командами через конвейер (|):

```shell
ps aux | grep "process_name"
```

ИЛИ

Этот пример показывает все запущенные процессы и фильтрует их по имени процесса process_name.

```shell
eslint . | grep -v "Computed property should have an explicit type"
```

Эта команда выведет все строки, кроме тех, которые содержат фразу “Computed property should have an explicit type”.

---

---

### xargs

#### Удаление файлов, соответствующих заданному шаблону:

* ```shell
      ls *.txt | xargs rm
    ```
    Этот пример передает список файлов с расширением .txt из вывода ls в команду rm, чтобы удалить все эти файлы.
* ```shell
      ls **/*.{ts,js,proto} | xargs rm
    ```
  Этот пример передает список файлов с расширением .ts, .js или .proto из всех папок из вывода ls в команду rm, чтобы удалить все эти файлы.

---

#### Остановить docker контейнеры

- `docker ps -aq | xargs -I {} docker stop {}`
  - `docker ps -aq` - Выводить список всех контейнеров
  - `xargs -I {} docker stop {}` - принимает список в `{}` и как бы по циклу передает в `docker stop {}` и во вторые фигурные скобки принимает элемент из списка

---

#### Удалить все docker образы по условию

```shell
docker images | grep "^image_name" | awk '{print $1}' | xargs -I {} docker rmi {}
```

- `docker images`: выводит список всех образов.
- `grep "^image_name"`: фильтрует строки, которые начинаются с `image_name`.
- `awk '{print $1}'`: извлекает первый столбец, который содержит названия образов.
- `xargs -I {} docker rmi {}`: передает каждое имя образа в команду `docker rmi` для удаления.

**Если есть теги, которые нужно учитывать, можно модифицировать команду, чтобы извлекать и имя образа, и тег:**

```shell
docker images | grep "^image_name" | awk '{print $1 ":" $2}' | xargs -I {} docker rmi {}
```

Таким образом, можно получить только названия образов (включая теги), которые можно
безопасно передать в `docker rmi` для удаления.

---

