### Дистрибутив

**Дистрибутив** - форма распространения какой-либо сущности

### Ядро

**Ядро** - основа операционной системы, которое непосредственно взаимадействует с железои, а вот уже с ядром взаимодействуют с помощью програм, например [*shell*](#gnu), а пользовательские приложение работают с [*shell*](#gnu).

### Linux

**Дистрибутив Linux** - форма распространения ядра Линукс, специально настроенных програм, диспетчера пакетов и утилит [*GNU*](#gnu)

> **Linux** - это не *Unix*.

**Linux=** - это Unix подобная система, которая использует *GNU*

**Linux** - Это ядро операционной системы. Операционные системы на базе Linux - установочный пакет ядра Linux + дополнительные пакеты с разными конфигурациями. ( *Ubuntu, Debian, Arch linux и т.д.* )

> При чем Ubuntu - построена на на самом Linux, а на  Debian

Ядро linux на 98% написано на языке C, на ассемблере написаны лишь небольшие вставки для производительности, архитектурных задач и сам загрузчик.

### GNU

**GNU** - Это и есть та самая основная штука, которая включает в себя shell/bash, cat, grep, awk.

### Процессы

В Linux есть 3 типа процессов - интерактивные, пакетные и демоны. Первые 2 могут запускаться пользователем, но интерактивные могут быть запущены через терминал, а демоны и пакетные не могут.

Что бы увидеть все выполняемые процессы в системе нужно выполнить следующую команду в терминале

`pstree`

**Пакетные процессы** - это различные скрипты резервного копирования или лругие подобные обслуживающие служебные сценарии. Как пакетные так и демоны работают в фоновом режиме.

**Демоны** отслеживают состояние той или иной сущности и гарантируют ее работоспособность ( *Типа ReplicaSet на подами в кубере* ).
Например демон принтера отслеживает состояние служб печати. Обычно названия демонов заканчиваются на "d"

Интерактивные нельзя считать демонами. Хоть их так же можно запустить в фоновом режиме, ключевое отличие в том что демонов не могут запускать пользователи.

Например, когда загрузка системы завершается, **systemd** начинает запускать демонов и интерактивные процессы. Точнее сначала программа начинает запускаться как обычный интерактивный процесс, но в какой-то момент начинает делиться на 2 идентичных потока. Это называется *forking*, разветвление. Первый поток привязан к терминалу и может продолжать работать дальше или завершиться по нужде пользователя, а вот второй уже не привязан к терминалу и в любом случае будет продолжать работать и завершить его пользователь не сможет.

#### Примеры Демонов Linux

**systemd** - следит за всеми демонами. Такой главный парень)
**udiskd** - все операции с внешними накопителями ( флешки )
**logind** - авторизация пользователя
**httpd** - демон веб-сервера, для реализации сайтов в ОС
**sshd** - поделючение к ОС удаленно, по протоколу *ssh*
**ftpd** - организовывет передачу файлов с удаленного ПК по протоколу FTP.
**crond** - планировщик задач, позволяет запускать задачи в определенное время.


### Командная оболочка

**Shell, Bash** и всякие другие программы - командная оболчка, которая позводяет запускать программы, управление дирректориеями, поиск программ в текущем каталоге и через пути PATH в конфиге тукущей оболчки. В общем по факту это надстройка над истинными командами ядра ОС. Например команда "cd", это не отдельная программа, а втроенная команда внутри оболочки. Но, например, ls - это уже внешняя программа, исполняемый файл которой лежит в файловой системе.

В системе может быть установлено несколько оболочек, но в одно время может работать только одна.

Что бы посмотреть какая оболчка у вас используется на данный момент, нужно выполнить команду:

`echo $SHELL` или `ps -p $$`

Для того что бы посмотреть все установленные оболочки:

`cat /etc/shells`

---

#### **Узнать ip машины**

Команды:

- `ip r | grep default`
- `netstat -r`

---

#### **Узнать свободен ли порт**

Команды:

- `sudo lsof -i :80`
  Если порт занят, ты увидишь список процессов, использующих этот порт. Если порт не занят, команда не вернет никаких результатов.
- `netstat -an | grep LISTEN`
  Эта команда выведет список всех портов, которые находятся в состоянии прослушивания.
- `netstat -tuln | grep LISTEN`
  Эта команда выведет список всех портов, которые находятся в состоянии прослушивания.
- `netstat -an | grep 80`
  Если порт занят, ты увидишь соответствующую строку в выводе. Если порт не занят, команда не вернет никаких результатов.
- `netstat -tuln | grep :80`
  Если порт занят, ты увидишь соответствующую строку в выводе. Если порт не занят, команда не вернет никаких результатов.
- `ss -tuln | grep :80`
  Команда ss является более современной и мощной заменой для netstat.
  Если порт 80 занят, ты увидишь информацию о процессе, который использует этот порт. Если он свободен, ничего не будет отображено.

---

#### Убить порт по PID

##### Проверить порт

Команда:

`lsof -i :80`

Выходные данные, если порт занят:

| COMMAND   | PID    | USER   | FD   | TYPE  | DEVICE | SIZE/OFF | NODE | NAME             |
| --------- | ------ | ------ | ---- | ----- | ------ | -------- | ---- | ---------------- |
| nginx     | 3402   | root   | 5u   | IPv4  | 34896  | 0t0      | TCP  | *:http (LISTEN)  |

##### Убить порт по PID

Команда:

`kill 3402`

**Если процесс не завершается, используй опцию -9 для принудительного завершения:**

Команда:

`kill -9 3402`

---

#### Добавить alias

Вы можете создать общий файл с alias'ами и затем импортировать его как в `bashrc`, так и в `zshrc`. Вот как это можно сделать:

1. Создайте новый файл для хранения ваших общих alias'ов, например `aliases.sh`:

```bash
touch ~/aliases.sh
```

2. Откройте этот файл и добавьте в него ваши alias'ы. Например:

```bash
# aliases.sh
alias ll='ls -alF'
alias gs='git status'
# Другие ваши alias'ы
```

3. Импортируйте этот файл как в `bashrc`, так и в `zshrc`. Для этого добавьте следующую строку в конец файла `~/.bashrc` и `~/.zshrc`:

```bash
source ~/aliases.sh
```

Теперь ваши alias'ы будут доступны как в `bash`, так и в `zsh`. Если вы захотите добавить новый alias или изменить существующий, вам нужно будет сделать это только в одном месте - в файле `aliases.sh`.

---

#### Команды с файлами и папками

**Скопировать файл**
```shell
cp path-folder desired-path-folder
```

---

**Скопировать папку**
```shell
cp -r path-folder desired-path-folder
```

---

**Узнать размер папок**
```shell
du -sh *
```
или
```shell
ls | xargs du -sh | less
```

---

**Отсортировать по подстроке из контента файлов**
```shell
ls -l | grep ".txt"
```

---

---

##### xargs

**Удаление файлов, соответствующих заданному шаблону:**
* ```shell
      ls *.txt | xargs rm
    ```
    Этот пример передает список файлов с расширением .txt из вывода ls в команду rm, чтобы удалить все эти файлы.
* ```shell
      ls **/*.{ts,js,proto} | xargs rm
    ```
  Этот пример передает список файлов с расширением .ts, .js или .proto из всех папок из вывода ls в команду rm, чтобы удалить все эти файлы.

---

**Копирование файлов из одного каталога в другой:**
```shell
find /path/to/source -name "*.txt" | xargs -I {} cp {} /path/to/destination
```
Этот пример использует find для поиска файлов с расширением .txt в исходном каталоге и передает их xargs, который в свою очередь копирует каждый файл в указанный каталог назначения.

---

**Использование множественных аргументов в команде:**
```shell
echo "file1.txt file2.txt file3.txt" | xargs cat
```
Здесь xargs получает список имен файлов от echo и передает их в команду cat, чтобы объединить содержимое всех файлов в один вывод.

---

**Выполнение команды с аргументами из файла:**
```shell
cat arguments.txt | xargs -I {} command {}
```
Этот пример передает аргументы из файла arguments.txt в команду command, которая выполняется для каждого аргумента.

---

**переименовать папку**
```shell
mv старое_название_папки новое_название_папки
```

---

**Посмотреть права и добавить права файлу**
* Посмотреть
```shell
ls -l
```
* Добавить
```shell
chmod +x tages-generate.sh
```
Права доступа к файлам:
В UNIX-подобных системах каждый файл и директория имеют атрибуты, определяющие, кто может читать, записывать и выполнять их.

**Эти атрибуты обычно представлены в виде трех групп:**

* Владелец файла (user): Пользователь, который создал файл или директорию.
* Группа (group): Группа, к которой принадлежит файл или директория.
* Остальные (others): Любые другие пользователи на системе, не являющиеся владельцем и не принадлежащие к группе.

**Для каждой из этих групп существует три основных права доступа:**

* Чтение (read): Позволяет просматривать содержимое файла или директории.
* Запись (write): Позволяет изменять содержимое файла или директории.
* Выполнение (execute): Позволяет запускать файл (для директорий - позволяет входить в них и просматривать их содержимое).

Каждое из этих прав можно установить или снять для каждой из трех групп пользователей (владельца, группы и остальных).

---

**Посмотреть различия между файлами**
* Просто узнать есть ли различия
```shell
cmp file1.txt file2.txt
```
* сравнить контент двух файлов
```shell
diff file1.txt file2.txt
```
* вывести различия в две колонки
```shell
diff -y file1.txt file2.txt
```
Эта команда выведет различия между file1.txt и file2.txt в две колонки, построчно. В левой колонке будут строки из file1.txt, а в правой из file2.txt. Если строки идентичны, будет использован символ | между ними. Если строки отличаются, будет использован символ < для строки из первого файла и > для строки из второго файла.
